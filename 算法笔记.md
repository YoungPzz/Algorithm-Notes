# 一、基础算法

### 1.排序

#### 1.1 快排

##### 思想

​	主要思想：**基于分治**

​	步骤：

​	①确定分界点：最左、最右、中间  三个取其一  ---->x

​	②调整区间：通过 x 划分区间，第一个区间小于等于 x，第二个区间大于等于 x 🌟

​	③递归处理左右两段区间

​	**关键：如何优雅地调整区间～**

- 方法一（暴力）：

  1. 开辟两个数组：a【】、b【】
  2. 遍历整个待排序的数组 q【left～right】，比 x 小的放在 a【】、比 x 大的放在 b【】
  3. 把 a 中的数放到q 里面去、把 b 中的数放到 q 里面去

- 方法二（优美）：

  思路：不需要开辟空间，运用两个指针i（红色） ，j（绿色）。

  ①i 往右走：当不满足小于 x 的值就停下

  ②j 往左走：当不满足大于 x 的值就停下

  ③ 双双交换，交换之后，两指针分别移动一位

  ④直到 i 大于等于 j ，至此，在 x 左边的都比 x 小，在 x 右边的都比 x 大

  ![image-20231011102135764](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231011102135764.png)

  例子：

  ​	3    1    2    3    5

  1. 取最左的数 3 为分界点

  ​        此时3(i)    1    2    3    5(j)    ，i和 j 分别指向 3 和 5

  2. i 不满足小于 3，所以 i 停下来

  3. j 满足大于 3，所以向左走，3(i)    1    2    3(j)     5 

  4. j 不满足 大于 3，所以停下来，两者互换  ---->3(i)    1    2    3(j)     5 

  5. 交换之后，两指针分别移动一位。---->3    1(i)    2(j)     3    5

  6. i 满足小于 3，向后移动一位，i 满足小于 2，再向后移动。---->3    1    2(j)     3(i)    5

  7. 此时 i 大于 j，停手。至此，以 j 分界，左边所有的数都是小于等于 3，右边所有的数都是大于等于 3

  

  *可以见得，这种题对于边界的界定要求很高，大家在面试或者笔试的过程中，很难有足够的时间或者稳定的心态把所有边界问题搞清楚，所以需有一套千锤百炼的模板*

  

##### 模板

```java
private static int[] quickSort(int[] arr, int left, int right) {
    // 递归终止条件，如果左边界大于等于右边界则认为递归结束
    if (left >= right) {
        return arr;
    }
    // 设定一个分界值，这里是（left + right）/ 2
    int p = arr[left + right >> 1];
    // 左右提前预留一个位置
    int i = left - 1;
    int j = right + 1;
    while (i < j) {
        // 等效于do while
        // 当数值小于分界值时持续遍历，直到找到第一个大于等于分界值的索引
        // 如果是逆序则调整两个while循环
        while (arr[++i] < p)
            ;
        while (arr[--j] > p)
            ;
        // 交换左右两侧不符合预期的数值
        if (i < j) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    // 由于分界值取的是left + right >> 1，因此递归取的是left，j j + 1，right
    quickSort(arr, left, j);
    quickSort(arr, j + 1, right);
    return arr;
}

```

```java
import java.util.Scanner;
import java.util.stream.IntStream;
public class Main {
public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    int n = in.nextInt();
    // Java8
    // IntStream.range等效于for循环
    // toArray生成数组
    int[] arr = IntStream.range(0, n).map(i -> in.nextInt()).toArray();
    int[] sortedArr = quickSort(arr, 0, n - 1);
    IntStream.range(0, n).mapToObj(i -> sortedArr[i] + " ").forEach(System.out::print);
    /*
    for (int i = 0; i < n; i++) {
        int a = in.nextInt();
        arr[i] = a;
    }
    int[] sortedArr = quickSort(arr, 0, n - 1);
    for (int i = 0; i < n; i++) {
        System.out.print(sortedArr[i] + " ");
    }
    */
}

private static int[] quickSort(int[] arr, int left, int right) {
   //
}
```

##### 注意事项

1. 

   ![image-20231011101251841](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231011101251841.png)

   理解：i 和 j 的位置，应当是 i 在前，j 在后，但是可能出现 j 在前，i 在后的场景

   如果此时递归函数使用的边界为 quickSort (arr, left ,i) 与  quickSort (arr, i +1  , right)

   就像反例中的 1(j) 3(i) 2. 只有 j 满足 左部分比 x 小，右部分比 x 大。

![image-20231011102413296](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231011102413296.png)

2. 关于快排，这篇 blog 写得很好，里面有很详细的注意事项。
   原文链接：https://blog.csdn.net/SHU15121856/article/details/109839618

##### 例子

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230926230923417.png" alt="image-20230926230923417" style="zoom:50%;" />

```java
import java.util.Scanner;
//第 k 个数
public class Main {
   public static void main(String[] args){
       Scanner in = new Scanner(System.in);
       int n = in.nextInt(), k = in.nextInt();
       int[] arr = new int[n + 1];
       for(int i = 1; i <= n; i++){
           arr[i] = in.nextInt();
       }
       quick_sort(arr, 1, n);
        System.out.println(arr[k]);
   }
   private static void quick_sort(int[] arr, int left, int right){
       if(left >= right) return;
       int l = left - 1;
       int r = right + 1;
       int x = arr[left + right >> 1];
       while(l < r) {
           while(arr[++l] < x) ;
           while(arr[--r] > x) ;
           if(l < r){
               int temp = arr[l];
               arr[l] = arr[r];
               arr[r] = temp;
           }
       }
       quick_sort(arr, left, r);
       quick_sort(arr, r+1 ,right);
       return;
   }



}
```

**注意：**这次做的时候遇到一个问题，产生了死循环。

因为我在

```java
int l = left;
       int r = right;
       int x = arr[left + right >> 1];
       while(l < r) {
           while(arr[l] < x) l++;
           while(arr[r] > x) r--;
//原本，包括上一题我都是这么写的，能过一些题，但是有些情况比较特殊，这样写直接造成了死循环
    //看一个例子！
      10 10
50 43 63 97 30 89 89 94 30 33
        取 x 的时候，取到的是 30
        然后第一次：
        50 43 63 97 30 89 89 94 30 33
         l                       r      l r 互换
        
        30 43 63 97 30 89 89 94 50 33   这种情况下，l 的值刚好等于x，所以 l 就出不去了，永远在 第一个位置！
        
```



#### 1.2 归并排序

**时间复杂度**：可由视频 40:00 得知（待总结

##### 思想

​	主要思想：**基于分治**

​	步骤：

​	①确定分界点：mid = （l+r）/ 2

​	②递归排序left，right

​	③归并——合二为一 🌟

##### 模版

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] arr = new int[n];
        for(int a = 0; a < n; a++){
            arr[a] = in.nextInt();
        }
        marge_sort(arr, 0, n-1);
        for(int a = 0; a < n; a++){
            System.out.print(arr[a] + " ");
        }
    }
    private static void marge_sort(int[] arr, int left, int right){
       if(left >= right) return;
        int mid = left + right >> 1;

        //先递归
        marge_sort(arr, left, mid);
        marge_sort(arr, mid+1, right);
        //再归并
        int i = left; int j = mid + 1;
        int[] temp = new int[right - left + 1]; //每次临时数组的长度
        int k = 0;
        while(i <= mid && j <= right){
            if(arr[i] <= arr[j]) temp[k++] = arr[i++];
            else temp[k++] = arr[j++];
        }
        while(i <= mid)
            temp[k++] = arr[i++];
        while(j <= right)
            temp[k++] = arr[j++];
        for(i = left,j = 0; i <= right; i++, j++){
            arr[i] = temp[j];
        }
       return;

    }

}
```

##### 例子

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230927105011751.png" alt="image-20230927105011751" style="zoom:50%;" />

``` java
//一开始暴力解！但是肯定是不行的啦，100000 个数，你暴力个毛线
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] arr = new int[n];
        for(int i = 0; i < n; i++){
            arr[i] = in.nextInt();
        }
        int k = 0;
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){
                if(arr[i] > arr[j]) k++;
            }
        }
        System.out.println(k);
    }
}
```

![image-20230927113815465](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230927113815465.png)

三种情况：逆序对同在 mid 左边、右边、或分在两边

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230927123003265.png" alt="image-20230927123003265" style="zoom:50%;" />

```java
//逆序对的数量
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr =  new int[n];
        for(int i = 0;i < n;i++){
            arr[i] = scanner.nextInt();
        }
        long result = mergeSort(arr,0,n-1);
        System.out.println(result);
    }
    public static long mergeSort(int[] arr,int left,int right){
        if(left >= right) return 0;

        int mid = (left + right) / 2 ;
        long result = mergeSort(arr,left,mid) + mergeSort(arr,mid + 1,right);

        int[] temp = new int[right - left + 1];
        int k = 0,i = left,j = mid + 1;
        while(i <= mid && j <= right){
            if(arr[i] <= arr[j]) temp[k ++ ] = arr[i ++ ];
            else{
                temp[k ++ ] = arr[j ++ ];
                result += mid - i + 1;
            }
        }
        while(i <= mid) temp[k ++ ] = arr[i ++ ];
        while(j <= right) temp[k ++ ] = arr[j ++ ];

        for(i = left,j = 0;i <= right;i++,j++){
            arr[i] = temp[j];
        }
        return result;
    }
}
```



### 2.二分

#### 2.1 整数

##### 思想

![image-20230921082711730](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230921082711730.png)

主要思想：找一个位置，使递增区间的左半边满足某个性能，右半边满足某个性能

每次二分出来红色段以及绿色段，以左右两个不同分界点的剪头，形成两套模板。

1.假设要寻找的数为 x，则**二分法将其分成>=x的右半部分和<x的左半部分，找右半部分的第一个数**

![image-20230921100304109](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230921100304109.png)

2.假设要寻找的数为 x，则**二分法将其分成<=x的左半部分和>x的右半部分，找左半部分的最后一个数**

![image-20230921100332773](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230921100332773.png)

##### 例子

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230921100707021.png" alt="image-20230921100707021" style="zoom:50%;" />

##### **模板**

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args){
       Scanner in = new Scanner(System.in);
       int n = in.nextInt(); //数的个数
       int m = in.nextInt(); //查询次数
       int[] arr = new int[n];
       for(int i = 0; i < n; i++){
           arr[i] = in.nextInt();
       }
       while(m-- > 0) { //查询次数
           int x = in.nextInt();
           int l = 0, r = n - 1;
           while(l < r){
               int mid = (l + r) / 2;
               //找右半部分的第一个数，左半部分都是小于 x 的
               if(arr[mid] >= x) r = mid; //为什么找右半部分的第一个数，是找 >= x的呢？：
             															//if（check（mid）） true or false ：check（mid）就是																					//看 arr【mid】满不满足绿色那段		
               else l = mid + 1;
           }
           //当 l = r 时，会退出
           if(arr[l] != x) System.out.println("-1 -1");
           else {
               System.out.print(l + " ");
               l = 0;
               r = n - 1;
               while(l < r){
                 int mid = (l + r + 1) / 2;//为什么要+1 呢：如 l = 3，r=4，l+r /2 = 3（向下取整）
                   if(arr[mid] <= x) l = mid;//如果没有+1，则 l永远等于 3，死循环了，所以l=mid 的情                        
                                             //况需要向上取证
                 else r = mid - 1;
               }
               System.out.println(l);
           }


       }
       return;
    }

}
```



#### 2.2 浮点数

##### 思想

主要思想：

(1) 首先找到数组的中间值，mid=(left+right)>>1，区间[left, right]被划分成[left, mid]和[mid , right]。

(2) 然后通过check(mid)判断中间值是不是满足这个性质，保证落到区间里就对了，check是根据不同的题型编写的。

(3) 最后就能使用折半，缩小区间了，当认为区间已经很小的时候，比如<=10^-6，其实就找到了答案。

**浮点数二分因为没有整除，每次都可以严格的缩小一半，所以不需要处理边界，相对简单**

##### 例子

#### <img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230922090551657.png" alt="image-20230922090551657" style="zoom:50%;" />

##### 模板

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args){
       Scanner in = new Scanner(System.in);
       double n = in.nextDouble(); //输入浮点数 n
       double l = -10000, r = 10000;
       while(r - l > 1e-8){ //10的负八次方
           double mid = (r + l) / 2;
           if(mid * mid * mid >= n) r = mid;
           else l = mid;
       }
        System.out.printf("%.6f",l);
       return;
    }

}
```

### 3.高精度计算

https://www.acwing.com/solution/content/34210/

**貌似 java 中不需要很严肃处理**

###  4.前缀和

##### 思想

主要思想：这道题理解起来算是简单题，就是求几个区间内连续的数字的和

Si = a1 + a2 + a3 + ... + ai 其中 S0 = 0；（注：数字为下标）

为什么要 S0 = 0 呢？涉及的是边界问题，假设要求 a7+a8+a9+...+a100 的和，适用S100 - S6 去计算

那么当要计算 a1 + a2 +... +ai ,计算的公式就是Si - S0。

##### 例子

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230922112125762.png" alt="image-20230922112125762" style="zoom:50%;" />

##### 模板

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args){
       Scanner in = new Scanner(System.in);
       int n = in.nextInt();
       int m = in.nextInt();
       int[] arr = new int[n+1];//输入的数字从 1 开始排，所以需要+1 个容量
       int[] S = new int[n+1];
        S[0] = 0;
       for(int i = 1; i <= n; i++){
           arr[i] = in.nextInt();
       } 
       for(int i = 1; i <= n; i++){
           S[i] = S[i - 1] + arr[i];//前缀和的初始化
       }
       while(m-- > 0){
           int i = in.nextInt();
           int j = in.nextInt();
           System.out.println(S[j] - S[i - 1]);//区间和的计算
       }
    }
}
```

### 5.二维前缀和

##### 思想

主要思想：

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230922160607512.png" alt="image-20230922160607512" style="zoom:50%;" />

如图所示一个二维数组，要求 **求阴影面积里数**的和。

其中Sx2y2 表示

![image-20230922160746082](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230922160746082.png)

这一面积里数的和，所以阴影面积里数的和等于图中的公式。

**如何把Sij 算出来**

![image-20230922163155597](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230922163155597.png)

##### **例子**

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230922163227148.png" alt="image-20230922163227148" style="zoom:50%;" />

##### 模版

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args){
      Scanner in = new Scanner(System.in);
      int n = in.nextInt();
      int m = in.nextInt();
      int q = in.nextInt();
      int[][] arr = new int[n+1][m+1];
      int[][] S = new int[n+1][m+1];
      for(int i = 1; i <= n; i++){ //输入数据
          for(int j = 1; j <= m; j++){
              arr[i][j] = in.nextInt();
          }
      }
      //处理每个Sij
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + arr[i][j];
            }
        }
      while(q-- > 0){
//          int i1 = in.nextInt(), j1 = in.nextInt(), i2 = in.nextInt(), j2 = in.nextInt();
//          System.out.println(S[i2][j2] - S[i1][j2] - S[i2][j1] + S[i1][j1]);
          int x1 = in.nextInt();
          int y1 = in.nextInt();
          int x2 = in.nextInt();
          int y2 = in.nextInt();
          System.out.println(S[x2][y2] - S[x2][y1 - 1] - S[x1 - 1][y2] + S[x1 - 1][y1 - 1]);
      }
    }
}
```

##### **注意事项**

```java
//          int i1 = in.nextInt(), j1 = in.nextInt(), i2 = in.nextInt(), j2 = in.nextInt();
//          System.out.println(S[i2][j2] - S[i1][j2] - S[i2][j1] + S[i1][j1]);
我写了最后求输出的时候，出错了，原因是对这个矩阵模型错误认知了，没有 - 1
```

![image-20230922230619649](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230922230619649.png)

如图所示，

要求灰色区域的面积，用S[x2] [y2] 就是<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230922230725204.png" alt="image-20230922230725204" style="zoom:50%;" />

这一段全部的面积，要减去粉红色的面积，我没有做减一处理

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230922230856224.png" alt="image-20230922230856224" style="zoom:50%;" />

这绿色框起来的，为S[x2] [ y1 - 1]

### 6. 差分

##### 思想

主要思想：

原数组 a1，a2，a3，a4，.....，an

构造数组 b1，b2，b3，b4，.....，bn

使得 bi = a1+a2+a3+...+ai    **a 数组是 b 数组的前缀和，b 数组称为 a 的差分**
<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230923223340057.png" alt="image-20230923223340057" style="zoom:50%;" />

如果有 b 数组，可以在 O（n）的时间复杂度算出 a 数组

##### 例子1

举个栗子，假设需要 a 数组，在[ l , r] 范围里 + 定值 c，al + c ，al+1 + c，al+2 + c. ....，ar + c

如果在 a 数组里操作，需要 O（n）的时间复杂度

但是**差分的好处来了，在 b 数组里，只需要 O（1）**

即使用 **bl + c**

 为什么呢？因为 al = b1 + b2 +...+ bl，bl + c，所以 al 也加上 c

al+1 = b1 + b2 + ... +bl + bl+1，al + 1 也加上了 c

所以只要操作一个 bl + c，即可以在 O（1）实现需求，很是方便！

但是需要加上一个 **补丁**，即 br+1 - c，不然ar 后面的所有值都会 + c 了！

##### 例子 2

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230923231443714.png" alt="image-20230923231443714" style="zoom:50%;" />

**关键点：如何初始化b 数组**

首先，把 a[] b[] 两数组都初始化为全部 0，这样也满足两数组差分和前缀和的性质，对吧？

然后，一个一个处理两个数组。

按照例2 的输入样例。首先 a[1] = 1 ,

整个 a 数组为 a： 1 0 0 0 0 0，**🌟就当作**例1 一样，在 l = r = 1 的范围里，插入 c = 1 去改造 b 数组.好理解吧！

所以此时，b 数组的 b[l] + c, b[r + 1] - c, 所以 b 数组为 1 -1 0 0 0 0

接下来就一个一个数字处理就好啦！

```java
import java.util.Scanner;

public class Main {
    static Scanner in = new Scanner(System.in);
    static int n;
    static int m;
    static  int N = 100010;
    static int[] a = new int[N];
    static int[] b = new int[N];

    private static void insert(int l, int r, int c) {
        b[l] += c;
        b[r + 1] -= c;
    }

    public static void main(String[] args){
     n = in.nextInt();
     m = in.nextInt();
     for(int i = 1; i <= n; i++){
         a[i] = in.nextInt();
     }
     for(int i = 1; i <= n; i++){
         insert(i, i , a[i]);
     }
     while(m -- > 0){
         int l = in.nextInt();
         int r = in.nextInt();
         int c = in.nextInt();
         insert(l, r, c);
     }
     for(int i = 1 ; i <= n ; i++){
         a[i] = a[i - 1] + b[i];
         System.out.print(a[i] + " ");
     }
    }


}
```

对于数组越界的问题

我这样做就不会有什么问题

```java
import java.util.Scanner;

public class Main {
    static Scanner in = new Scanner(System.in);
    static int n;
    static int m;
    static int[] a ;
    static int[] b ;

    private static void insert(int l, int r, int c) {
        b[l] += c;
        b[r + 1] -= c;
    }

    public static void main(String[] args){
     n = in.nextInt();
     m = in.nextInt();
     a = new int[n + 1]; //这里
     b = new int[n + 2]; //这里 + 2 的原因是 insert 里面 r 还要 + 1
      //所以他们都是用N = 100010 直接定义了
      for(int i = 1; i <= n; i++){
         a[i] = in.nextInt();
     }
     for(int i = 1; i <= n; i++){
         insert(i, i , a[i]);
     }
     while(m -- > 0){
         int l = in.nextInt();
         int r = in.nextInt();
         int c = in.nextInt();
         insert(l, r, c);
     }
     for(int i = 1 ; i <= n ; i++){
         a[i] = a[i - 1] + b[i];
         System.out.print(a[i] + " ");
     }
    }


}
```

### 7. 差分矩阵

##### 思想

主要思想：

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230925202400144.png" alt="image-20230925202400144" style="zoom:50%;" />

*有原二维矩阵**a**ij，构造差分二维矩阵 **b**ij，使得 **a**ij 为 **b**ij 左上角所有数的和；*

**构造：**与上面一样，使得两个二维数组的初始化都为 0；

一维差分是在数组的一段加上一个值，二维的话是给其中一个子矩阵加上一个值

**关键图示如图所示：**

![image-20230925204410774](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230925204410774.png)

##### 例子

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230925204743717.png" alt="image-20230925204743717" style="zoom: 50%;" />

##### 模版

```java
import java.util.Scanner;
//差分矩阵
public class Main {
     static int n,m;
     static int[][] arr, brr;
    public static void main(String[] args) {
      Scanner in = new Scanner(System.in);
      n = in.nextInt(); m = in.nextInt();
      int q = in.nextInt();
      arr = new int[n+10][m+10];
      brr = new int[n+10][m+10];
      for(int i = 1; i <= n; i++){
          for(int j = 1; j <= m; j++){
              arr[i][j] = in.nextInt();
              insert(i, j, i, j, arr[i][j]);
          }
      }
      while(q -- > 0){
          int x1 = in.nextInt(), y1 = in.nextInt(), x2 = in.nextInt(), y2 = in.nextInt();
          int c = in.nextInt();
          insert(x1, y1, x2, y2, c);
      }
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                arr[i][j] = brr[i][j] + arr[i][j-1] + arr[i-1][j] - arr[i-1][j-1];
              //由 b 数组求前缀和得到最终的 a 数组
              //arr[i][j - 1]就是 brr[i][j] 左侧一个点的左上角所有数的和
                System.out.print(arr[i][j] + " ");
                if(j == m) System.out.println();
            }
        }
    }
    private static void insert(int x1, int y1, int x2, int y2, int c){
        brr[x1][y1] += c;
        brr[x2+1][y1] -= c;
        brr[x1][y2+1] -= c;
        brr[x2+1][y2+1] += c;
    }

}
```

### 8.双指针算法

##### 思想

主要思想：

两大类：

①归并排序的两个有序序列合并过程也是个双指针算法。这种是指针在两个不同的序列。

②还有一类是类似于快排的过程，如快排时的两个指针。

大部分都是如下的写法：

```java
for(i = 0,j = 0; i < n; i++){
  while(j < i &&check(i,j)) j++;
  //每道题目的具体逻辑
}
```

双指针算法核心思想：**优化 **，时间复杂度 O(n)；把暴力做法优化到 O(n)。

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230930162409209.png" alt="image-20230930162409209" style="zoom:40%;" />

 例如这道题。输入 abc def ghi 。要求是把每个单词输出出来。

显然可以用暴力 的方法，套两层 for 循环来解决。

##### 例子

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20230930162809114.png" alt="image-20230930162809114" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231013083922269.png" alt="image-20231013083922269" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231001161747870.png" alt="image-20231001161747870" style="zoom:50%;" />

##### 模板

```java
package com.company;

import java.util.Scanner;
public class Main {
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int[] a = new int[100010];
        int[] s = new int[100010];
        for(int i = 0 ; i < n ; i ++ ){
            a[i] = scan.nextInt();
        }
        int res = 0;
        for(int i = 0 , j = 0 ;i < n ; i ++ ){
            //比如一开始S[2]是0；然后你的a[1] = 2;那么s[2] = 1;
            //然后如果a[2] = 2 ;那么第二次出现所以s[2] = 2;这样来证明是不是出现两次
            s[a[i]] ++ ;
            while(j < i && s[a[i]] > 1){
                //一开始j是跟i在同个位置，i在移动，j原地不动，只要上面出现两次，j开始移动
                //移动到 j 的极限，即区间内没有重复数字
                s[a[j]] -- ;
                j++;
            }
            //i-j+1是统计长度的公式；
            res = Math.max(res, i-j+1); System.out.println(res);

        }
        System.out.println(res);
    }

```

### 9.位运算

##### 思想

问题：一个整数 n，它的二进制表示中，第 k 位数是几？

比如： n =15 ，二进制表示：1111.（个位是第 0 位）

方法：①将 n 右移动 k 位。如 1111 的第 2 位，就移动两次。1111 >>2   ------>.  0011

​           ②将末位 与 1.（1 与 1 是 1 ，1 与 0 是 0）

##### lowbitx

![image-20231013085247191](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231013085247191.png)

**lowbitx 的计算方法：**

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231013090309242.png" alt="image-20231013090309242" style="zoom:50%;" />

知识点：x 的负数表示，在二进制中为：～x + 1

x 与 -x 可以求得 x 的最后一位 1

##### 例子

<img src="../Library/Application%20Support/typora-user-images/image-20231013090858439.png" alt="image-20231013090858439" style="zoom:50%;" />

##### 模板

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args){
       Scanner scanner = new Scanner(System.in);
       int n = scanner.nextInt();
       while(n-- > 0){
           int x = scanner.nextInt();
           int res = 0;
           while(x != 0) {
               x -= lowbit(x);
               res++;
           }
           System.out.print(res + " ");
       }

    }
    private static int lowbit(int x){
        return x & -x;
    }

}
```

##### 原、补、反码

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231013095055462.png" alt="image-20231013095055462" style="zoom:50%;" />

提问：为什么计算机存储负数，不直接用反码呢？

答：计算机在底层实现的时候，是没有减法的，所以用加法来做减法。

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231013095956609.png" alt="image-20231013095956609" style="zoom:50%;" />

-x 相当于0 - x

相当于 0000....0000 （32 位的 0 减去 x）

向前借一位 1 才能减，所以为 1 000...000（32 个 0）表示为～x + 1

### 10.离散化

##### 思想

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231013112605347.png" alt="image-20231013112605347" style="zoom:50%;" />

假设有 10的5次方个整数，值域为 0～10 的9次方

 要把这么多个数映射到以 0 开始的自然数序列

① a【】数组中可能有重复元素 ：**去重**

② 如何算出 a【i】离散化后的值是多少：**二分**

##### 模版

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231014215539671.png" alt="image-20231014215539671" style="zoom:50%;" />

##### 例子

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231014220526874.png" alt="image-20231014220526874" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231014220719799.png" alt="image-20231014220719799" style="zoom:50%;" />

![image-20231014220427360](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231014220427360.png)

如果值比较小（如-10 的 5 次方到 10 的 5 次方），直接用前缀和做。

如此一道题，如果在每个数组对应的下标填入对应的值，会造成一大堆数组位置用不到的情况

**整个数值的跨度很大，但是很稀疏**，这样的情况可以想到用离散化来做

所以可以把所有的数，映射到从 1 开始的自然数



```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();// 输入n次操作
        int m = scan.nextInt();//输入m次询问
        int N = 300010;//注意事项①🌟
        int[] a =  new int[N]; //用来存值,从一开始的值，因为要用到前缀和，所以0不操作；
        int[] s = new int[N];//用来存前缀和，从一开始进行记录a数组；
        List<Integer> alls = new ArrayList<>();//用来存所有的下标，x,l,r;
        List<Pair> add = new ArrayList<>();//用来存n次操作
        List<Pair> query = new ArrayList<>();//用来存m次询问
        //输入n次操作，每次操作存入add集合中，然后将下标x存入alls集合中
        for(int i = 0 ; i < n ; i ++ ){
            int x = scan.nextInt();
            int c = scan.nextInt();
            add.add(new Pair(x,c));
            alls.add(x);
        }
        //输入m次询问，每次询问存入query集合中，因为l,r是求和的下标区间和，所以l,r都存入alls集合中。
        for(int i = 0 ; i < m ; i ++ ){
            int l = scan.nextInt();
            int r = scan.nextInt();
            query.add(new Pair(l,r));
            alls.add(l);
            alls.add(r);
        }

        Collections.sort(alls);   //排序，现在alls集合中存的是x，l，r所有值
        int unique = unique(alls);  // //注意事项②🌟
        alls = alls.subList(0,unique);  //将去重之后的alls的长度范围中的值重新赋值给alls集合中。

        //增强for循环 for(元素类型 变量名 ： 数组或者集合) 缺点：无下标，简单。
        for(Pair item : add){//注意事项③🌟
            int index = find(item.first,alls);//
            a[index] += item.second;//
        }

        for(int i = 1 ; i <= alls.size() ; i ++ ) s[i] = s[i-1] + a[i]; //这是前缀和公式代码

        for(Pair item : query){
            int l = find(item.first,alls); // 
            int r = find(item.second,alls); // 
            System.out.println(s[r] - s[l-1]); // 
        }

    }
    //去重（只要符合是第一个数或者后面一个数不等于前面一个数就是不重复的数）
    public static int unique(List<Integer> list){
        int j = 0;
        for(int i = 0 ; i <= list.size() - 1; i ++ ){
            if(i == 0 || list.get(i) != list.get(i-1)){
                list.set(j,list.get(i)); //将不重复之后的数一个一个重新存入list中。
                j ++ ;
            }
        }
        return j;
    }
    //二分查找（在集合中查找你现在的下标是在什么位置，因为需要符合我们要用的前缀和公式，要让下标不是从0输出，最低的下标是1，符合前缀和的从1开始，所以输出的值加1）
    public static int find(int x ,List<Integer> list){
        int l  = 0;
        int r = list.size() - 1;
        while(l < r){
            int mid = ( l + r )/ 2;
            if(list.get(mid) >= x) r = mid;
            else l = mid + 1;
        }
        return l + 1;
    }
}
//Pair类，用来存操作的类
class Pair{
    int first;
    int second;
    public Pair(int x,int c){
        this.first = x;
        this.second = c;
    }
}

```

##### 注意事项

①：为什么要开辟 300000 个位置？答：首先 n，m 操作的次数范围为<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231015173435210.png" alt="image-20231015173435210" style="zoom:50%;" />

​	按照最最最极端的情况下考虑，每次 n 、 m 操作（m 操作每次操作2 个数组的位置）。

​	所以假设为每次 n，m 都操作不同的下标。

②为什么要去重、排序？答：理解这个必须理解整道题的思路、核心点：**离散化**。该题的离散化，正是将要操作的**数组下标**进行离散化，如这道题的例子输入为示例，进行 add 操作时操作了 *数组下标* 1、3、7 ，进行 query 操作时操作了 *数组下标*1 3 4 6 7 8。alls 数组的作用就是将所有需要操作的下标集合起来到数组。

回到最初的问题，为什么要去重。正是因为离散化后的数组只需要知道 **哪个数组下标需要操作**

为什么要排序？离散化就是将 被操作的数组下标，从小到大映射到 a 数组 的序列中 从 1 开始排序（因为需要进行前缀和操作，所以从 1 开始）

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231015205826205.png" alt="image-20231015205826205" style="zoom:50%;" />

​																未进行去重、排序前的 alls 数组

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231015205703747.png" alt="image-20231015205703747" style="zoom:50%;" />

​																进行去重、排序前的 alls 数组

③需要被操作的下标已经被去重、排序了，那么怎么样知道哪个下标的值应该进行+c 操作呢？

答：List<Pair> add = new ArrayList<>();

前期的这句代码，已经将需要操作的原数组下标存储到Pair 类中了。通过 Pair 类查找该原数组下标在 去重、排序后的 alls 数组里的下标，再进行 add 操作。

查询操作也是如此，通过Pair类里存储的需要查询的 l，r。再去找 l，r 现在对应的 alls 数组的下标，进行操作。

离散化的核心就很明确了，只需要操作需要操作的数组下标，未被操作的数组下标对应的值为 0，进行前缀和时可以忽略不记。

### 11.区间合并

# 二、数据结构

### 1.链表与邻接表

##### 思想：

一般不用节点、指针的方法实现，因为这样**非常慢**。试着用数组的方法实现。

笔试题一般不这样用，因为数据量大。

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231018234620925.png" alt="image-20231018234620925" style="zoom:50%;" />

##### 单链表：

用得最多的是邻接表。

邻接表最多的应用是**存储图和数**。

用数组来实现单链表：

​	用 e[]  来存储每个节点的 value。

​	用 ne[]来存储每个节点的 next 指针。

那 e 与 ne 如何关联起来呢？答：数组下标。

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231018235559392.png" alt="image-20231018235559392" style="zoom:50%;" />



##### 双链表：

用来优化某些问题。

# 五、动态规划

### 1.背包问题

#### 1.1 01背包

情景：

N个物品 ，单个物品的体积v(i) 价值w(i). i为下标

V容量的背包

**每个物品最多使用一次** 状态为0或1.所以称之为01背包问题

需求：在背包能装得下的情况夏，求背包的最大价值。

##### 例子

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231020090807088.png" alt="image-20231020090807088" style="zoom:50%;" />

题目的物品参数如下图： 

 <img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231019215449020.png" alt="image-20231019215449020" style="zoom:25%;" />

**做题思考方式：**

![image-20231019220555229](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231019220555229.png)

其中，状态表示：思考要用几维来表示题目的状态，状态的含义是什么

​			状态计算：如何一步一步把每个状态算出来

​			集合：例如此题是选择哪些个物品的集合

​			属性：一般为max、min、数量。（此题求的显然是max）

重要条件：只从前i个物品中选，选中的物品总体积小于等于j 的条件下 产生的 **集合**

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231019221900503.png" alt="image-20231019221900503" style="zoom: 25%;" />

**状态的计算**实质上是集合的划分，f（i，j）的所有集合中，分成两大类，一类含i，一类不含i。左边集合的最大值是**f（i-1，j）**

<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231019222446228.png" alt="image-20231019222446228" style="zoom:25%;" />

右边（包含第i个物品）--- 的最大值**f（ i-1，j-v(i) )  + w(i)** : 

（假设小明的分数是全班最高的，当班主任为了班里的整体分数好看，全班同学都+上20分。但小明分数最高的情况没有变）

最终的f（i，j） = max （左边最大，右边最大）

##### 朴素题解

朴素做法用到的数组是二维的

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        int N = 1010;
        int[] v = new int[N];
        int[] w = new int[N];
        int[][] f = new int[N][N];
        int n = scan.nextInt();
        int m = scan.nextInt();
        for(int i = 1 ; i <= n ; i ++ ){
            v[i] = scan.nextInt();
            w[i] = scan.nextInt();
        }
      //初始化为f[0][0~m] = 0;二维数组构建时已经默认值为0了，所以可以省略
      
        for(int i = 1 ; i <= n ; i ++ ){
            for(int j = 0 ; j <= m ; j ++ ){
                f[i][j] = f[i - 1][j]; // 左边不包含i的方案
                if(j >= v[i])  f[i][j] = Math.max(f[i][j] , f[i - 1][j - v[i]] + w[i]);//右边包含i的方案，f[i-1][j - v[i]] + w[i]
            }
        }
        System.out.println(f[n][m]);
    }
}

```

##### 优化做法

![image-20231019231154916](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231019231154916.png)

- 为什么可以转化为一维：对于原来的dp更新公式，我们可以发现，对于第i层的更新，只会用到第i-1层的数据，不会涉及i-2及前面的值，简单理解就是，我只需要保存一行（此题n=4、m=5在二维的情况下表示4行5列），下一段i（j从1～5）的情况下，只需要用已经存在的i-1（j从1～5）中的数据就可以实现更新。

- 如何理解<img src="https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231020090126291.png" alt="image-20231020090126291" style="zoom:40%;" />

  分为两种情况。（要知道，f[j] = 的含义是，在当前for循环的第i层中（只从前i个物品中选），容量为j时的最大价值。！！f数组的意义是记录最大值）。

  1.不取当前位置i的物品：**此时呢和i - 1数组上的值是相同的**，所以不用改变。所以f[j] = f[j].

  2.取当前位置i的物品：让总体积 j 减去 当前位置i的体积，j - v [i]，得到减去v[i]后的最大值f[ j - v[i] ],再+w[i]

- 为什么j要逆序更新。**只用一个数组，每次都覆盖前面的数组。**考虑一个情况。i的层数为 1 2  3 4 5。现在准备更新i = 2这一层。此时的f[1] ~ f[5]的值为

  2  2  2  2  2。例如要更新f[3]，1⃣️不取i（即不取当前i位置的物品），**此时呢和i - 1数组上的值是相同的**，所以不用改变。即f[3] = f[3]。2⃣️取i（即取到当前i位置到物品），此时需要和前一位置的信息取max。即f[3] = 

  Max(f[3], f[3 - v[3]] + w[3] ) 即Max(2, 6)  = 6。

  *可以见得，更新f[3]，需要用到f[0]，即用到上一层3前面的数据（0，1，2），所以只能逆序更新。

  

  ![image-20231020084633783](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231020084633783.png)

  ![image-20231020154558887](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231020154558887.png)

  也就是说，01问题去掉i所处的维度后，根据状态转移方程，f i -1 j -v 转换为f j -v 。该层用到上层i的值，但现在只有j[] 一维数组。为了保留上层的值，只能从大到小。

  而完全背包问题，用到的是本层所需的数组，所以得从小到大。

```java
 import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        int N = 1010;
        int[] v = new int[N];
        int[] w = new int[N];
        int[] f = new int[N];
        int n = scan.nextInt();
        int m = scan.nextInt();
        for(int i = 1 ; i <= n ; i ++ ){
            v[i] = scan.nextInt();
            w[i] = scan.nextInt();
        }
        for(int i = 1 ; i <= n ; i ++ ){
            for(int j = m ; j >= v[i] ; j -- ){

                f[j] = Math.max(f[j] , f[j - v[i]] + w[i]);
        }
    }
    System.out.println(f[m]);
}}
```


#### 1.2 完全背包

**每个物品有无限个，只要体积够用，就可以无限装**

先说结论！**在01背包的基础上，把j由逆序改为正序即可**，就是这么神奇。

```java
         for(int i = 1 ; i <= n ; i ++ ){
            for(int j = v[i] ; j <= m ; j ++){
         f[j] = Math.max(f[j] , f[j - v[i]] + w[i]);
    }
```

![image-20231020094426654](../Library/Application%20Support/typora-user-images/image-20231020094426654.png)

y氏dp分析法，状态表示依旧使用f（i，j），分为集合与属性。

集合：只从前 i 个物品中选，总体积不超过j。

属性：f（i，j）代表的数值含义，很明显这里是价值MAX最大值。

状态计算：与01背包问题不同的是，01背包只分为选不选当前的第 i 个物品，但是完全背包则麻烦多了，原文第i个物品，**可以选取无数个**，所以状态的划分要分为第 i 个物品选0，1，2，...., k次。直到超过体积为止。

**f(i,j) = max( f(i - 1,j) , f( i - 1, j - v) + w, f(i - 1, j - 2v) + 2w ............. )**

​					 i选0次。  i选1次。				i选2次。            ..........

其中，v代表 v(i)

**重点：这么长的这么多项表达式，如何化简呢？如何变成只有两项呢。**

推导：

![image-20231020101530702](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231020101530702.png)

原式子：**f(i,j) = max( f(i - 1,j) , f( i - 1, j - v) + w, f(i - 1, j - 2v) + 2w ............. )**

转换式：**f(i,j - v) = max( f(i - 1,j - v) , f( i - 1, j - 2v) + w, f(i - 1, j - 3v) + 2w ............. )**       

**原式除了f(i - 1,j)  的后半部分，正是 转换式 + w**

​    **可见f(i,j) = max( f(i - 1), j ), f(i , j - v ) + w)**

![image-20231020102409899](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231020102409899.png)

可以见得，完全背包问题与01背包问题的区别，**仅有f[i-1] 与 f[i]**

##### 朴素题解

```Java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        int N = 1010;
        int[] v = new int[N];
        int[] w = new int[N];
        int[][] f = new int[N][N];
        int n = scan.nextInt();
        int m = scan.nextInt();
        for(int i = 1 ; i <= n ; i ++ ){
            v[i] = scan.nextInt();
            w[i] = scan.nextInt();
        }

        for(int i = 1 ; i <= n ; i ++ ){
            for(int j = 0 ; j <= m ; j ++ ){
                f[i][j] = f[i - 1][j]; // 表示我们划分的第一个不包含i的方案

                // 划分的包含1-k个i的方案,因为可能不存在，所以需要判断一下，v[i]的大小是不是超过总容量j
                if (j >= v[i]) f[i][j] = Math.max(f[i][j] , f[i][j - v[i]] + w[i]);
            }
        }
        System.out.println(f[n][m]);
    }
}
```

##### 优化做法

![image-20231020105649964](https://raw.githubusercontent.com/YoungPzz/markdown-img/master/image-20231020105649964.png)

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        int N = 1010;
        int[] v = new int[N];
        int[] w = new int[N];
        int[] f = new int[N];//去掉一维，看是否等价
        int n = scan.nextInt();
        int m = scan.nextInt();
        for(int i = 1 ; i <= n ; i ++ ){
            v[i] = scan.nextInt();
            w[i] = scan.nextInt();
        }

        for(int i = 1 ; i <= n ; i ++ ){
            for(int j = v[i] ; j <= m ; j ++ ){
                //代码等价变形，有点像01背包问题，只是将上面的第二重循环从大到小变成从小到大
                f[j] = f[j];// 原本f[i][j] = f[i - 1][j]; 左边是要算的该第i层，等式先算右边再算左边，右边的f[j]为还没更新的f[j]，即上一层i得f[j]，所以等价为f[i-1][j];
                f[j] = Math.max(f[j],f[j - v[i]] + w[i]);
              //if (j >= v[i]) f[i][j] = Math.max(f[i][j] , f[i][j - v[i]] + w[i]);
              
              
            }
        }
        System.out.println(f[m]);
    }
}
```



#### 1.3 多重背包

**每个物品的数量不一**



#### 1.3 分组背包

**物品有n组，每组有若干个**