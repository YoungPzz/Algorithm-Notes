# 一、基础算法

### 1.排序

#### 1.1 快排

##### 思想

​	主要思想：**基于分治**

​	步骤：

​	①确定分界点：最左、最右、中间  三个取其一  ---->x

​	②调整区间：通过 x 划分区间，第一个区间小于等于 x，第二个区间大于等于 x 🌟

​	③递归处理左右两段区间

​	**关键：如何优雅地调整区间～**

- 方法一（暴力）：

  1. 开辟两个数组：a【】、b【】
  2. 遍历整个待排序的数组 q【left～right】，比 x 小的放在 a【】、比 x 大的放在 b【】
  3. 把 a 中的数放到q 里面去、把 b 中的数放到 q 里面去

- 方法二（优美）：

  思路：不需要开辟空间，运用两个指针i（红色） ，j（绿色）。

  ①i 往右走：当不满足小于 x 的值就停下

  ②j 往左走：当不满足大于 x 的值就停下

  ③ 双双交换，交换之后，两指针分别移动一位

  ④直到 i 大于等于 j ，至此，在 x 左边的都比 x 小，在 x 右边的都比 x 大

  ![image-20230918204105161](/Users/youngp/Library/Application Support/typora-user-images/image-20230918204105161.png)

  例子：

  ​	3    1    2    3    5

  1. 取最左的数 3 为分界点

  ​        此时3(i)    1    2    3    5(j)    ，i和 j 分别指向 3 和 5

  2. i 不满足小于 3，所以 i 停下来

  3. j 满足大于 3，所以向左走，3(i)    1    2    3(j)     5 

  4. j 不满足 大于 3，所以停下来，两者互换  ---->3(i)    1    2    3(j)     5 

  5. 交换之后，两指针分别移动一位。---->3    1(i)    2(j)     3    5

  6. i 满足小于 3，向后移动一位，i 满足小于 2，再向后移动。---->3    1    2(j)     3(i)    5

  7. 此时 i 大于 j，停手。至此，以 j 分界，左边所有的数都是小于等于 3，右边所有的数都是大于等于 3

  

  *可以见得，这种题对于边界的界定要求很高，大家在面试或者笔试的过程中，很难有足够的时间或者稳定的心态把所有边界问题搞清楚，所以需有一套千锤百炼的模板*

  

##### 模板

```java
private static int[] quickSort(int[] arr, int left, int right) {
    // 递归终止条件，如果左边界大于等于右边界则认为递归结束
    if (left >= right) {
        return arr;
    }
    // 设定一个分界值，这里是（left + right）/ 2
    int p = arr[left + right >> 1];
    // 左右提前预留一个位置
    int i = left - 1;
    int j = right + 1;
    while (i < j) {
        // 等效于do while
        // 当数值小于分界值时持续遍历，直到找到第一个大于等于分界值的索引
        // 如果是逆序则调整两个while循环
        while (arr[++i] < p)
            ;
        while (arr[--j] > p)
            ;
        // 交换左右两侧不符合预期的数值
        if (i < j) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    // 由于分界值取的是left + right >> 1，因此递归取的是left，j j + 1，right
    quickSort(arr, left, j);
    quickSort(arr, j + 1, right);
    return arr;
}

```

```java
import java.util.Scanner;
import java.util.stream.IntStream;
public class Main {
public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    int n = in.nextInt();
    // Java8
    // IntStream.range等效于for循环
    // toArray生成数组
    int[] arr = IntStream.range(0, n).map(i -> in.nextInt()).toArray();
    int[] sortedArr = quickSort(arr, 0, n - 1);
    IntStream.range(0, n).mapToObj(i -> sortedArr[i] + " ").forEach(System.out::print);
    /*
    for (int i = 0; i < n; i++) {
        int a = in.nextInt();
        arr[i] = a;
    }
    int[] sortedArr = quickSort(arr, 0, n - 1);
    for (int i = 0; i < n; i++) {
        System.out.print(sortedArr[i] + " ");
    }
    */
}

private static int[] quickSort(int[] arr, int left, int right) {
   //
}
```

##### 注意事项

1. ![image-20230919223535473](/Users/youngp/Library/Application Support/typora-user-images/image-20230919223535473.png)

   理解：i 和 j 的位置，应当是 i 在前，j 在后，但是可能出现 j 在前，i 在后的场景

   如果此时递归函数使用的边界为 quickSort (arr, left ,i) 与  quickSort (arr, i +1  , right)

   就像反例中的 1(j) 3(i) 2. 只有 j 满足 左部分比 x 小，右部分比 x 大。

2. ![image-20230925185427019](/Users/youngp/Library/Application Support/typora-user-images/image-20230925185427019.png)

3. 关于快排，这篇 blog 写得很好，里面有很详细的注意事项。
   原文链接：https://blog.csdn.net/SHU15121856/article/details/109839618

##### 例子

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230926230923417.png" alt="image-20230926230923417" style="zoom:50%;" />

```java
import java.util.Scanner;
//第 k 个数
public class Main {
   public static void main(String[] args){
       Scanner in = new Scanner(System.in);
       int n = in.nextInt(), k = in.nextInt();
       int[] arr = new int[n + 1];
       for(int i = 1; i <= n; i++){
           arr[i] = in.nextInt();
       }
       quick_sort(arr, 1, n);
        System.out.println(arr[k]);
   }
   private static void quick_sort(int[] arr, int left, int right){
       if(left >= right) return;
       int l = left - 1;
       int r = right + 1;
       int x = arr[left + right >> 1];
       while(l < r) {
           while(arr[++l] < x) ;
           while(arr[--r] > x) ;
           if(l < r){
               int temp = arr[l];
               arr[l] = arr[r];
               arr[r] = temp;
           }
       }
       quick_sort(arr, left, r);
       quick_sort(arr, r+1 ,right);
       return;
   }



}
```

**注意：**这次做的时候遇到一个问题，产生了死循环。

因为我在

```java
int l = left;
       int r = right;
       int x = arr[left + right >> 1];
       while(l < r) {
           while(arr[l] < x) l++;
           while(arr[r] > x) r--;
//原本，包括上一题我都是这么写的，能过一些题，但是有些情况比较特殊，这样写直接造成了死循环
    //看一个例子！
      10 10
50 43 63 97 30 89 89 94 30 33
        取 x 的时候，取到的是 30
        然后第一次：
        50 43 63 97 30 89 89 94 30 33
         l                       r      l r 互换
        
        30 43 63 97 30 89 89 94 50 33   这种情况下，l 的值刚好等于x，所以 l 就出不去了，永远在 第一个位置！
        
```



#### 1.2 归并排序

**时间复杂度**：可由视频 40:00 得知（待总结

##### 思想

​	主要思想：**基于分治**

​	步骤：

​	①确定分界点：mid = （l+r）/ 2

​	②递归排序left，right

​	③归并——合二为一 🌟

##### 模版

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] arr = new int[n];
        for(int a = 0; a < n; a++){
            arr[a] = in.nextInt();
        }
        marge_sort(arr, 0, n-1);
        for(int a = 0; a < n; a++){
            System.out.print(arr[a] + " ");
        }
    }
    private static void marge_sort(int[] arr, int left, int right){
       if(left >= right) return;
        int mid = left + right >> 1;

        //先递归
        marge_sort(arr, left, mid);
        marge_sort(arr, mid+1, right);
        //再归并
        int i = left; int j = mid + 1;
        int[] temp = new int[right - left + 1]; //每次临时数组的长度
        int k = 0;
        while(i <= mid && j <= right){
            if(arr[i] <= arr[j]) temp[k++] = arr[i++];
            else temp[k++] = arr[j++];
        }
        while(i <= mid)
            temp[k++] = arr[i++];
        while(j <= right)
            temp[k++] = arr[j++];
        for(i = left,j = 0; i <= right; i++, j++){
            arr[i] = temp[j];
        }
       return;

    }

}
```

##### 例子

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230927105011751.png" alt="image-20230927105011751" style="zoom:50%;" />

``` java
//一开始暴力解！但是肯定是不行的啦，100000 个数，你暴力个毛线
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] arr = new int[n];
        for(int i = 0; i < n; i++){
            arr[i] = in.nextInt();
        }
        int k = 0;
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){
                if(arr[i] > arr[j]) k++;
            }
        }
        System.out.println(k);
    }
}
```

![image-20230927113815465](/Users/youngp/Library/Application Support/typora-user-images/image-20230927113815465.png)

三种情况：逆序对同在 mid 左边、右边、或分在两边

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230927123003265.png" alt="image-20230927123003265" style="zoom:50%;" />

```java
//逆序对的数量
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr =  new int[n];
        for(int i = 0;i < n;i++){
            arr[i] = scanner.nextInt();
        }
        long result = mergeSort(arr,0,n-1);
        System.out.println(result);
    }
    public static long mergeSort(int[] arr,int left,int right){
        if(left >= right) return 0;

        int mid = (left + right) / 2 ;
        long result = mergeSort(arr,left,mid) + mergeSort(arr,mid + 1,right);

        int[] temp = new int[right - left + 1];
        int k = 0,i = left,j = mid + 1;
        while(i <= mid && j <= right){
            if(arr[i] <= arr[j]) temp[k ++ ] = arr[i ++ ];
            else{
                temp[k ++ ] = arr[j ++ ];
                result += mid - i + 1;
            }
        }
        while(i <= mid) temp[k ++ ] = arr[i ++ ];
        while(j <= right) temp[k ++ ] = arr[j ++ ];

        for(i = left,j = 0;i <= right;i++,j++){
            arr[i] = temp[j];
        }
        return result;
    }
}
```



### 2.二分

#### 2.1 整数

##### 思想

![image-20230921082711730](/Users/youngp/Library/Application Support/typora-user-images/image-20230921082711730.png)

主要思想：找一个位置，使递增区间的左半边满足某个性能，右半边满足某个性能

每次二分出来红色段以及绿色段，以左右两个不同分界点的剪头，形成两套模板。

1.假设要寻找的数为 x，则**二分法将其分成>=x的右半部分和<x的左半部分，找右半部分的第一个数**

![image-20230921100304109](/Users/youngp/Library/Application Support/typora-user-images/image-20230921100304109.png)

2.假设要寻找的数为 x，则**二分法将其分成<=x的左半部分和>x的右半部分，找左半部分的最后一个数**

![image-20230921100332773](/Users/youngp/Library/Application Support/typora-user-images/image-20230921100332773.png)

##### 例子

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230921100707021.png" alt="image-20230921100707021" style="zoom:50%;" />

##### **模板**

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args){
       Scanner in = new Scanner(System.in);
       int n = in.nextInt(); //数的个数
       int m = in.nextInt(); //查询次数
       int[] arr = new int[n];
       for(int i = 0; i < n; i++){
           arr[i] = in.nextInt();
       }
       while(m-- > 0) { //查询次数
           int x = in.nextInt();
           int l = 0, r = n - 1;
           while(l < r){
               int mid = (l + r) / 2;
               //找右半部分的第一个数，左半部分都是小于 x 的
               if(arr[mid] >= x) r = mid; //为什么找右半部分的第一个数，是找 >= x的呢？：
             															//if（check（mid）） true or false ：check（mid）就是																					//看 arr【mid】满不满足绿色那段		
               else l = mid + 1;
           }
           //当 l = r 时，会退出
           if(arr[l] != x) System.out.println("-1 -1");
           else {
               System.out.print(l + " ");
               l = 0;
               r = n - 1;
               while(l < r){
                 int mid = (l + r + 1) / 2;//为什么要+1 呢：如 l = 3，r=4，l+r /2 = 3（向下取整）
                   if(arr[mid] <= x) l = mid;//如果没有+1，则 l永远等于 3，死循环了，所以l=mid 的情                        
                                             //况需要向上取证
                 else r = mid - 1;
               }
               System.out.println(l);
           }


       }
       return;
    }

}
```



#### 2.2 浮点数

##### 思想

主要思想：

(1) 首先找到数组的中间值，mid=(left+right)>>1，区间[left, right]被划分成[left, mid]和[mid , right]。

(2) 然后通过check(mid)判断中间值是不是满足这个性质，保证落到区间里就对了，check是根据不同的题型编写的。

(3) 最后就能使用折半，缩小区间了，当认为区间已经很小的时候，比如<=10^-6，其实就找到了答案。

**浮点数二分因为没有整除，每次都可以严格的缩小一半，所以不需要处理边界，相对简单**

##### 例子

#### <img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230922090551657.png" alt="image-20230922090551657" style="zoom:50%;" />

##### 模板

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args){
       Scanner in = new Scanner(System.in);
       double n = in.nextDouble(); //输入浮点数 n
       double l = -10000, r = 10000;
       while(r - l > 1e-8){ //10的负八次方
           double mid = (r + l) / 2;
           if(mid * mid * mid >= n) r = mid;
           else l = mid;
       }
        System.out.printf("%.6f",l);
       return;
    }

}
```

### 3.高精度计算

https://www.acwing.com/solution/content/34210/

**貌似 java 中不需要很严肃处理**

###  4.前缀和

##### 思想

主要思想：这道题理解起来算是简单题，就是求几个区间内连续的数字的和

Si = a1 + a2 + a3 + ... + ai 其中 S0 = 0；（注：数字为下标）

为什么要 S0 = 0 呢？涉及的是边界问题，假设要求 a7+a8+a9+...+a100 的和，适用S100 - S6 去计算

那么当要计算 a1 + a2 +... +ai ,计算的公式就是Si - S0。

##### 例子

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230922112125762.png" alt="image-20230922112125762" style="zoom:50%;" />

##### 模板

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args){
       Scanner in = new Scanner(System.in);
       int n = in.nextInt();
       int m = in.nextInt();
       int[] arr = new int[n+1];//输入的数字从 1 开始排，所以需要+1 个容量
       int[] S = new int[n+1];
        S[0] = 0;
       for(int i = 1; i <= n; i++){
           arr[i] = in.nextInt();
       } 
       for(int i = 1; i <= n; i++){
           S[i] = S[i - 1] + arr[i];//前缀和的初始化
       }
       while(m-- > 0){
           int i = in.nextInt();
           int j = in.nextInt();
           System.out.println(S[j] - S[i - 1]);//区间和的计算
       }
    }
}
```

### 5.二维前缀和

##### 思想

主要思想：

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230922160607512.png" alt="image-20230922160607512" style="zoom:50%;" />

如图所示一个二维数组，要求 **求阴影面积里数**的和。

其中Sx2y2 表示

![image-20230922160746082](/Users/youngp/Library/Application Support/typora-user-images/image-20230922160746082.png)

这一面积里数的和，所以阴影面积里数的和等于图中的公式。

**如何把Sij 算出来**

![image-20230922163155597](/Users/youngp/Library/Application Support/typora-user-images/image-20230922163155597.png)

##### **例子**

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230922163227148.png" alt="image-20230922163227148" style="zoom:50%;" />

##### 模版

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args){
      Scanner in = new Scanner(System.in);
      int n = in.nextInt();
      int m = in.nextInt();
      int q = in.nextInt();
      int[][] arr = new int[n+1][m+1];
      int[][] S = new int[n+1][m+1];
      for(int i = 1; i <= n; i++){ //输入数据
          for(int j = 1; j <= m; j++){
              arr[i][j] = in.nextInt();
          }
      }
      //处理每个Sij
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + arr[i][j];
            }
        }
      while(q-- > 0){
//          int i1 = in.nextInt(), j1 = in.nextInt(), i2 = in.nextInt(), j2 = in.nextInt();
//          System.out.println(S[i2][j2] - S[i1][j2] - S[i2][j1] + S[i1][j1]);
          int x1 = in.nextInt();
          int y1 = in.nextInt();
          int x2 = in.nextInt();
          int y2 = in.nextInt();
          System.out.println(S[x2][y2] - S[x2][y1 - 1] - S[x1 - 1][y2] + S[x1 - 1][y1 - 1]);
      }
    }
}
```

##### **注意事项**

```java
//          int i1 = in.nextInt(), j1 = in.nextInt(), i2 = in.nextInt(), j2 = in.nextInt();
//          System.out.println(S[i2][j2] - S[i1][j2] - S[i2][j1] + S[i1][j1]);
我写了最后求输出的时候，出错了，原因是对这个矩阵模型错误认知了，没有 - 1
```

![image-20230922230619649](/Users/youngp/Library/Application Support/typora-user-images/image-20230922230619649.png)

如图所示，

要求灰色区域的面积，用S[x2] [y2] 就是<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230922230725204.png" alt="image-20230922230725204" style="zoom:50%;" />

这一段全部的面积，要减去粉红色的面积，我没有做减一处理

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230922230856224.png" alt="image-20230922230856224" style="zoom:50%;" />

这绿色框起来的，为S[x2] [ y1 - 1]

### 6. 差分

##### 思想

主要思想：

原数组 a1，a2，a3，a4，.....，an

构造数组 b1，b2，b3，b4，.....，bn

使得 bi = a1+a2+a3+...+ai    **a 数组是 b 数组的前缀和，b 数组称为 a 的差分**
<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230923223340057.png" alt="image-20230923223340057" style="zoom:50%;" />

如果有 b 数组，可以在 O（n）的时间复杂度算出 a 数组

##### 例子1

举个栗子，假设需要 a 数组，在[ l , r] 范围里 + 定值 c，al + c ，al+1 + c，al+2 + c. ....，ar + c

如果在 a 数组里操作，需要 O（n）的时间复杂度

但是**差分的好处来了，在 b 数组里，只需要 O（1）**

即使用 **bl + c**

 为什么呢？因为 al = b1 + b2 +...+ bl，bl + c，所以 al 也加上 c

al+1 = b1 + b2 + ... +bl + bl+1，al + 1 也加上了 c

所以只要操作一个 bl + c，即可以在 O（1）实现需求，很是方便！

但是需要加上一个 **补丁**，即 br+1 - c，不然ar 后面的所有值都会 + c 了！

##### 例子 2

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230923231443714.png" alt="image-20230923231443714" style="zoom:50%;" />

**关键点：如何初始化b 数组**

首先，把 a[] b[] 两数组都初始化为全部 0，这样也满足两数组差分和前缀和的性质，对吧？

然后，一个一个处理两个数组。

按照例2 的输入样例。首先 a[1] = 1 ,

整个 a 数组为 a： 1 0 0 0 0 0，**🌟就当作**例1 一样，在 l = r = 1 的范围里，插入 c = 1 去改造 b 数组.好理解吧！

所以此时，b 数组的 b[l] + c, b[r + 1] - c, 所以 b 数组为 1 -1 0 0 0 0

接下来就一个一个数字处理就好啦！

```java
import java.util.Scanner;

public class Main {
    static Scanner in = new Scanner(System.in);
    static int n;
    static int m;
    static  int N = 100010;
    static int[] a = new int[N];
    static int[] b = new int[N];

    private static void insert(int l, int r, int c) {
        b[l] += c;
        b[r + 1] -= c;
    }

    public static void main(String[] args){
     n = in.nextInt();
     m = in.nextInt();
     for(int i = 1; i <= n; i++){
         a[i] = in.nextInt();
     }
     for(int i = 1; i <= n; i++){
         insert(i, i , a[i]);
     }
     while(m -- > 0){
         int l = in.nextInt();
         int r = in.nextInt();
         int c = in.nextInt();
         insert(l, r, c);
     }
     for(int i = 1 ; i <= n ; i++){
         a[i] = a[i - 1] + b[i];
         System.out.print(a[i] + " ");
     }
    }


}
```

对于数组越界的问题

我这样做就不会有什么问题

```java
import java.util.Scanner;

public class Main {
    static Scanner in = new Scanner(System.in);
    static int n;
    static int m;
    static int[] a ;
    static int[] b ;

    private static void insert(int l, int r, int c) {
        b[l] += c;
        b[r + 1] -= c;
    }

    public static void main(String[] args){
     n = in.nextInt();
     m = in.nextInt();
     a = new int[n + 1]; //这里
     b = new int[n + 2]; //这里 + 2 的原因是 insert 里面 r 还要 + 1
      //所以他们都是用N = 100010 直接定义了
      for(int i = 1; i <= n; i++){
         a[i] = in.nextInt();
     }
     for(int i = 1; i <= n; i++){
         insert(i, i , a[i]);
     }
     while(m -- > 0){
         int l = in.nextInt();
         int r = in.nextInt();
         int c = in.nextInt();
         insert(l, r, c);
     }
     for(int i = 1 ; i <= n ; i++){
         a[i] = a[i - 1] + b[i];
         System.out.print(a[i] + " ");
     }
    }


}
```

### 7. 差分矩阵

##### 思想

主要思想：

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230925202400144.png" alt="image-20230925202400144" style="zoom:50%;" />

*有原二维矩阵**a**ij，构造差分二维矩阵 **b**ij，使得 **a**ij 为 **b**ij 左上角所有数的和；*

**构造：**与上面一样，使得两个二维数组的初始化都为 0；

一维差分是在数组的一段加上一个值，二维的话是给其中一个子矩阵加上一个值

**关键图示如图所示：**

![image-20230925204410774](/Users/youngp/Library/Application Support/typora-user-images/image-20230925204410774.png)

##### 例子

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230925204743717.png" alt="image-20230925204743717" style="zoom: 50%;" />

##### 模版

```java
import java.util.Scanner;
//差分矩阵
public class Main {
     static int n,m;
     static int[][] arr, brr;
    public static void main(String[] args) {
      Scanner in = new Scanner(System.in);
      n = in.nextInt(); m = in.nextInt();
      int q = in.nextInt();
      arr = new int[n+10][m+10];
      brr = new int[n+10][m+10];
      for(int i = 1; i <= n; i++){
          for(int j = 1; j <= m; j++){
              arr[i][j] = in.nextInt();
              insert(i, j, i, j, arr[i][j]);
          }
      }
      while(q -- > 0){
          int x1 = in.nextInt(), y1 = in.nextInt(), x2 = in.nextInt(), y2 = in.nextInt();
          int c = in.nextInt();
          insert(x1, y1, x2, y2, c);
      }
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                arr[i][j] = brr[i][j] + arr[i][j-1] + arr[i-1][j] - arr[i-1][j-1];
              //由 b 数组求前缀和得到最终的 a 数组
              //arr[i][j - 1]就是 brr[i][j] 左侧一个点的左上角所有数的和
                System.out.print(arr[i][j] + " ");
                if(j == m) System.out.println();
            }
        }
    }
    private static void insert(int x1, int y1, int x2, int y2, int c){
        brr[x1][y1] += c;
        brr[x2+1][y1] -= c;
        brr[x1][y2+1] -= c;
        brr[x2+1][y2+1] += c;
    }

}
```

### 8.双指针算法

##### 思想

主要思想：

两大类：

①归并排序的两个有序序列合并过程也是个双指针算法。这种是指针在两个不同的序列。

②还有一类是类似于快排的过程，如快排时的两个指针。

大部分都是如下的写法：

```java
for(i = 0,j = 0; i < n; i++){
  while(j < i &&check(i,j)) j++;
  //每道题目的具体逻辑
}
```

双指针算法核心思想：**优化 **，时间复杂度 O(n)；把暴力做法优化到 O(n)。

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230930162409209.png" alt="image-20230930162409209" style="zoom:40%;" />

 例如这道题。输入 abc def ghi 。要求是把每个单词输出出来。

显然可以用暴力 的方法，套两层 for 循环来解决。

##### 例子

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230930162809114.png" alt="image-20230930162809114" style="zoom:50%;" />

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20230930163110353.png" alt="image-20230930163110353" style="zoom:33%;" />

<img src="/Users/youngp/Library/Application Support/typora-user-images/image-20231001161747870.png" alt="image-20231001161747870" style="zoom:50%;" />

##### 模板

```java
package com.company;

import java.util.Scanner;
public class Main {
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int[] a = new int[100010];
        int[] s = new int[100010];
        for(int i = 0 ; i < n ; i ++ ){
            a[i] = scan.nextInt();
        }
        int res = 0;
        for(int i = 0 , j = 0 ;i < n ; i ++ ){
            //比如一开始S[2]是0；然后你的a[1] = 2;那么s[2] = 1;
            //然后如果a[2] = 2 ;那么第二次出现所以s[2] = 2;这样来证明是不是出现两次
            s[a[i]] ++ ;
            while(j < i && s[a[i]] > 1){
                //一开始j是跟i在同个位置，i在移动，j原地不动，只要上面出现两次，j开始移动
                //移动到 j 的极限，即区间内没有重复数字
                s[a[j]] -- ;
                j++;
            }
            //i-j+1是统计长度的公式；
            res = Math.max(res, i-j+1); System.out.println(res);

        }
        System.out.println(res);
    }
}
```

​                       